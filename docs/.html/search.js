window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "src", "modulename": "src", "kind": "module", "doc": "<p><img src=\"https://img.shields.io/pypi/v/:slune-lib\" alt=\"PyPI - Version\" />\n<a href=\"LICENSE\"><img src=\"https://img.shields.io/badge/License-MIT-purple.svg\" alt=\"license\" /></a>\n<img src=\"https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/h-0-0/4aa01e058fee448070c587f6967037e4/raw/CodeCovSlune.json\" alt=\"badge\" /></p>\n\n<p><img src=\"https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/h-0-0/4aa01e058fee448070c587f6967037e4/raw/Tests-macos.json\" alt=\"badge\" />\n<img src=\"https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/h-0-0/4aa01e058fee448070c587f6967037e4/raw/Tests-ubuntu.json\" alt=\"badge\" />\n<img src=\"https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/h-0-0/4aa01e058fee448070c587f6967037e4/raw/Tests-windows.json\" alt=\"badge\" /></p>\n\n<h1 id=\"slune-slurm-tune\">slune (= slurm + tune!)</h1>\n\n<p>A super simplistic python package for performing hyperparameter tuning (or more generally launching jobs and saving results) on a cluster using SLURM. Takes advantage of the fact that lots of jobs (including hyperparameter tuning) are embarrassingly parallel! With slune you can divide your compute into lots of separately scheduled jobs meaning that each small job can get running on your cluster more quickly, speeding up your workflow! Often significantly! </p>\n\n<p>Slune is super-easy to use! We have helper functions which can execute everything you need done for you. Letting you speed up your work without wasting time. </p>\n\n<p>Slune is barebones by design. This means that you can easily write code to integrate with slune if you want to do something a bit different! You can also workout what each function is doing pretty easily. </p>\n\n<p>Slune is flexible. In designing this package I've tried to make as few assumptions as possible meaning that it can be used for lots of stuff outside hyperparameter tuning! (or also within!) For example, you can get slune to give you paths for where to save things, submit lots of jobs in parallel for any sort of script and do grid search! and there's more to come!</p>\n\n<h2 id=\"usage\">Usage</h2>\n\n<p>Let's go through a quick example of how we can use slune ... first let's define a model that we want to train:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"c1\"># Simple Regularized Linear Regression without using external libraries</span>\n\n<span class=\"c1\"># Function to compute the mean of a list</span>\n<span class=\"k\">def</span> <span class=\"nf\">mean</span><span class=\"p\">(</span><span class=\"n\">values</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">values</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">values</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># Function to compute the covariance between two lists</span>\n<span class=\"k\">def</span> <span class=\"nf\">covariance</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">mean_x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">mean_y</span><span class=\"p\">):</span>\n    <span class=\"n\">covar</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)):</span>\n        <span class=\"n\">covar</span> <span class=\"o\">+=</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">mean_x</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">mean_y</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">covar</span>\n\n<span class=\"c1\"># Function to compute the variance of a list</span>\n<span class=\"k\">def</span> <span class=\"nf\">variance</span><span class=\"p\">(</span><span class=\"n\">values</span><span class=\"p\">,</span> <span class=\"n\">mean</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"nb\">sum</span><span class=\"p\">((</span><span class=\"n\">x</span> <span class=\"o\">-</span> <span class=\"n\">mean</span><span class=\"p\">)</span> <span class=\"o\">**</span> <span class=\"mi\">2</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"n\">values</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Function to compute coefficients for a simple regularized linear regression</span>\n<span class=\"k\">def</span> <span class=\"nf\">coefficients_regularized</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"p\">):</span>\n    <span class=\"n\">mean_x</span><span class=\"p\">,</span> <span class=\"n\">mean_y</span> <span class=\"o\">=</span> <span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">),</span> <span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n    <span class=\"n\">var_x</span> <span class=\"o\">=</span> <span class=\"n\">variance</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">mean_x</span><span class=\"p\">)</span>\n    <span class=\"n\">covar</span> <span class=\"o\">=</span> <span class=\"n\">covariance</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">mean_x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">mean_y</span><span class=\"p\">)</span>\n    <span class=\"n\">b1</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">covar</span> <span class=\"o\">+</span> <span class=\"n\">alpha</span> <span class=\"o\">*</span> <span class=\"n\">var_x</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"p\">(</span><span class=\"n\">var_x</span> <span class=\"o\">+</span> <span class=\"n\">alpha</span><span class=\"p\">)</span>\n    <span class=\"n\">b0</span> <span class=\"o\">=</span> <span class=\"n\">mean_y</span> <span class=\"o\">-</span> <span class=\"n\">b1</span> <span class=\"o\">*</span> <span class=\"n\">mean_x</span>\n    <span class=\"k\">return</span> <span class=\"n\">b0</span><span class=\"p\">,</span> <span class=\"n\">b1</span>\n\n<span class=\"c1\"># Function to make predictions with a simple regularized linear regression model</span>\n<span class=\"k\">def</span> <span class=\"nf\">linear_regression_regularized</span><span class=\"p\">(</span><span class=\"n\">train_X</span><span class=\"p\">,</span> <span class=\"n\">train_y</span><span class=\"p\">,</span> <span class=\"n\">test_X</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"p\">):</span>\n    <span class=\"n\">b0</span><span class=\"p\">,</span> <span class=\"n\">b1</span> <span class=\"o\">=</span> <span class=\"n\">coefficients_regularized</span><span class=\"p\">(</span><span class=\"n\">train_X</span><span class=\"p\">,</span> <span class=\"n\">train_y</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"p\">)</span>\n    <span class=\"n\">predictions</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">b0</span> <span class=\"o\">+</span> <span class=\"n\">b1</span> <span class=\"o\">*</span> <span class=\"n\">x</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"n\">test_X</span><span class=\"p\">]</span>\n    <span class=\"k\">return</span> <span class=\"n\">predictions</span>\n\n<span class=\"c1\"># ------------------</span>\n<span class=\"c1\"># The above is code for a simple normalized linear regression model that we want to train.</span>\n<span class=\"c1\"># Now let&#39;s fit the model and use slune to save how well our model performs!</span>\n<span class=\"c1\"># ------------------</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">&quot;__main__&quot;</span><span class=\"p\">:</span>\n    <span class=\"c1\"># First let&#39;s load in the value for the regularization parameter alpha that has been passed to this script from the command line. We will use the slune helper function lsargs to do this. </span>\n    <span class=\"c1\"># lsargs returns a tuple of the python path and a list of arguments passed to the script. We can then use this to get the alpha value.</span>\n    <span class=\"kn\">from</span> <span class=\"nn\">slune</span> <span class=\"kn\">import</span> <span class=\"n\">lsargs</span>\n    <span class=\"n\">python_path</span><span class=\"p\">,</span> <span class=\"n\">args</span> <span class=\"o\">=</span> <span class=\"n\">lsargs</span><span class=\"p\">()</span>\n    <span class=\"n\">alpha</span> <span class=\"o\">=</span> <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n\n    <span class=\"c1\"># Mock training dataset, function is y = 1 + 1 * x</span>\n    <span class=\"n\">X</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]</span>\n    <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">]</span>\n\n    <span class=\"c1\"># Mock test dataset</span>\n    <span class=\"n\">test_X</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">]</span>\n    <span class=\"n\">test_y</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"p\">]</span>\n    <span class=\"n\">test_predictions</span> <span class=\"o\">=</span> <span class=\"n\">linear_regression_regularized</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">test_X</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># First let&#39;s load in a function that we can use to get a saver object that uses the default method of logging (we call this object a slog = saver + logger). The saving will be coordinated by a csv saver object which saves and reads results from csv files stored in a hierarchy of directories.</span>\n    <span class=\"kn\">from</span> <span class=\"nn\">slune</span> <span class=\"kn\">import</span> <span class=\"n\">get_csv_slog</span>\n    <span class=\"n\">csv_slog</span> <span class=\"o\">=</span> <span class=\"n\">get_csv_slog</span><span class=\"p\">(</span><span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"n\">args</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Let&#39;s now calculate the mean squared error of our predictions and log it!</span>\n    <span class=\"n\">mse</span> <span class=\"o\">=</span> <span class=\"n\">mean</span><span class=\"p\">((</span><span class=\"n\">test_y</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">test_predictions</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">test_y</span><span class=\"p\">)))</span>\n    <span class=\"n\">csv_slog</span><span class=\"o\">.</span><span class=\"n\">log</span><span class=\"p\">({</span><span class=\"s1\">&#39;mse&#39;</span><span class=\"p\">:</span> <span class=\"n\">mse</span><span class=\"p\">})</span>\n\n    <span class=\"c1\"># Let&#39;s now save our logged results!</span>\n    <span class=\"n\">slog</span><span class=\"o\">.</span><span class=\"n\">save_collated</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n\n<p>Now let's write some code that will submit some jobs to train our model using different hyperparameters!!</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"c1\"># Let&#39;s now load in a function that will coordinate our search! We&#39;re going to do a grid search.</span>\n<span class=\"c1\"># SearcherGrid is the class we can use to coordinate a grid search. We pass it a dictionary of hyperparameters and the values we want to try for each hyperparameter. We also pass it the number of runs we want to do for each combination of hyperparameters.</span>\n<span class=\"kn\">from</span> <span class=\"nn\">slune.searchers</span> <span class=\"kn\">import</span> <span class=\"n\">SearcherGrid</span>\n<span class=\"n\">grid_searcher</span> <span class=\"o\">=</span> <span class=\"n\">SearcherGrid</span><span class=\"p\">({</span><span class=\"s1\">&#39;alpha&#39;</span> <span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mf\">0.25</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.75</span><span class=\"p\">]},</span> <span class=\"n\">runs</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Let&#39;s now import a function which will submit a job for our model, the script_path specifies the path to the script that contains the model we want to train. The template_path specifies the path to the template script that we want to specify the job with, cargs is a list of constant arguments we want to pass to the script for each tuning. </span>\n<span class=\"c1\"># We set slog to None as we don&#39;t want to not run jobs if we have already run them before.</span>\n<span class=\"kn\">from</span> <span class=\"nn\">slune</span> <span class=\"kn\">import</span> <span class=\"n\">sbatchit</span>\n<span class=\"n\">script_path</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;model.py&#39;</span>\n<span class=\"n\">template_path</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;template.sh&#39;</span>\n<span class=\"n\">sbatchit</span><span class=\"p\">(</span><span class=\"n\">script_path</span><span class=\"p\">,</span> <span class=\"n\">template_path</span><span class=\"p\">,</span> <span class=\"n\">grid_searcher</span><span class=\"p\">,</span> <span class=\"n\">cargs</span><span class=\"o\">=</span><span class=\"p\">[],</span> <span class=\"n\">slog</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Now we've submitted our jobs we will wait for them to finish \ud83d\udd5b\ud83d\udd50\ud83d\udd51\ud83d\udd52\ud83d\udd53\ud83d\udd54\ud83d\udd55\ud83d\udd56\ud83d\udd57\ud83d\udd58\ud83d\udd59\ud83d\udd5a\ud83d\udd5b, now that they are finished we can read the results!</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span> <span class=\"nn\">slune</span> <span class=\"kn\">import</span> <span class=\"n\">get_csv_slog</span>\n<span class=\"n\">csv_slog</span> <span class=\"o\">=</span> <span class=\"n\">get_csv_slog</span><span class=\"p\">(</span><span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"kc\">None</span><span class=\"p\">)</span>\n<span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">csv_slog</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"p\">[],</span> <span class=\"n\">metric_name</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;mse&#39;</span><span class=\"p\">,</span> <span class=\"n\">select_by</span> <span class=\"o\">=</span><span class=\"s1\">&#39;min&#39;</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">&#39;Best hyperparameters: </span><span class=\"si\">{</span><span class=\"n\">params</span><span class=\"si\">}</span><span class=\"s1\">&#39;</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">&#39;Their MSE: </span><span class=\"si\">{</span><span class=\"n\">value</span><span class=\"si\">}</span><span class=\"s1\">&#39;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Amazing! \ud83e\udd73 We have successfully used slune to train our model. I hope this gives you a good flavour of how you can use slune and how easy it is to use!</p>\n\n<p>Please check out the examples folder for notebooks detailing in more depth some potential ways you can use slune. The docs are not yet up and running \ud83d\ude22 but they are coming soon!</p>\n\n<h2 id=\"roadmap\">Roadmap</h2>\n\n<ul>\n<li>Make package user friendly:\n<ul>\n<li>Go through automation settings.</li>\n<li>Code of conduct.</li>\n<li>Contributing guidelines.</li>\n<li>Add to pypi.\nStill in early stages! First thing on the horizon is better integration with SLURM:</li>\n</ul></li>\n<li>Set-up notifications for job completion, failure, etc.</li>\n<li>Auto job naming, job output naming and job output location saving.</li>\n<li>Auto save logged results when finishing a job.</li>\n<li>Automatically re-submit failed jobs.</li>\n<li>Tools for monitoring and cancelling jobs. \nThen it will be looking at adding more savers, loggers and searchers! For example integration with tensorboard, saving to one csv file (as opposed to a hierarchy of csv files in different directories) and different search methods like random search and cross validation. It would perhaps also be beneficial to be able to interface with other languages like R and Julia. Finally, more helper functions!</li>\n</ul>\n\n<p>However, I am trying to keep this package as bloatless as possible to make it easy for you to tweak and configure to your individual needs. It's written in a simple and compartmentalized manner for this reason. You can of course use the helper functions and let slune handle everything under the hood, but, you can also very quickly and easily write your own classes to work with other savers, loggers and searchers to do as you please.</p>\n\n<h2 id=\"installation\">Installation</h2>\n\n<p>To install latest version use:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>pip<span class=\"w\"> </span>install<span class=\"w\"> </span>slune-lib\n</code></pre>\n</div>\n\n<p>To install latest dev version use (CURRENTLY RECOMENDED):</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"c1\"># With https</span>\npip<span class=\"w\"> </span>install<span class=\"w\"> </span><span class=\"s2\">&quot;git+https://github.com/h-aze/slune.git#egg=slune-lib&quot;</span>\n</code></pre>\n</div>\n\n<h1 id=\"class-design\">Class Design</h1>\n\n<p>Here we will outline the different kind of classes that are used in slune and how they interact with each other. There are 3 types:</p>\n\n<ul>\n<li>'Searcher' classes - these are the classes that are used to define and traverse a search space.</li>\n<li>'Logger' classes - these are the classes that are used to create and read log files.</li>\n<li>'Saver' classes - these are the classes that are used to save logs to files and read logs from files.</li>\n</ul>\n\n<p>The base module is where the base classes for each of these types are defined. The base classes are:</p>\n\n<ul>\n<li>BaseSearcher</li>\n<li>BaseLogger</li>\n<li>BaseSaver</li>\n</ul>\n\n<p>To create a new searcher, logger or saver, you must inherit from the appropriate base class and implement the required methods. The required methods will have the '@abc.abstractmethod' decorator above them and will throw errors if they are not implemented. The compulsory methods allow for well-defined interactions between the different classes and should allow for any combination of searcher, logger and saver to be used together. </p>\n\n<p>Please read the docs for the base classes to see what methods are required to be implemented and how they should be implemented.</p>\n"}, {"fullname": "src.slune", "modulename": "src.slune", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.slune.base", "modulename": "src.slune.base", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.slune.base.BaseSearcher", "modulename": "src.slune.base", "qualname": "BaseSearcher", "kind": "class", "doc": "<p>Base class for all Searchers. </p>\n\n<p>This must be subclassed to create different Searcher classes.\nPlease name your searcher class Searcher<SearcherName>\nOutlines a protocol for creating a search space and creating configurations from it.\nMethods document what they should do once implemented.</p>\n"}, {"fullname": "src.slune.base.BaseSearcher.__init__", "modulename": "src.slune.base", "qualname": "BaseSearcher.__init__", "kind": "function", "doc": "<p>Initialises the searcher.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "src.slune.base.BaseSearcher.next_tune", "modulename": "src.slune.base", "qualname": "BaseSearcher.next_tune", "kind": "function", "doc": "<p>Returns the next configuration to try.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.slune.base.BaseSearcher.check_existing_runs", "modulename": "src.slune.base", "qualname": "BaseSearcher.check_existing_runs", "kind": "function", "doc": "<p>Used to tell searcher to check if there are existing runs in storage.</p>\n\n<p>If there are existing runs, the searcher should skip them \nbased on the number of runs we would like for each job.\nThis may require a 'runs' attribute to be set in the searcher.\nIt will probably also require access to a Saver object,\nso we can use it's saving protocol to check if there are existing runs.\nIn this case is advised that this function takes a Saver object as an argument,\nand that the searcher is initialized with a 'runs' attribute.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.slune.base.BaseLogger", "modulename": "src.slune.base", "qualname": "BaseLogger", "kind": "class", "doc": "<p>Base class for all Loggers. </p>\n\n<p>This must be subclassed to implement different Logger classes.\nPlease name your logger class Logger<LoggerName>.\nOutlines a protocol for logging metrics and reading from the logs.\nMethods document what they should do once implemented.</p>\n"}, {"fullname": "src.slune.base.BaseLogger.__init__", "modulename": "src.slune.base", "qualname": "BaseLogger.__init__", "kind": "function", "doc": "<p>Initialises the logger.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "src.slune.base.BaseLogger.log", "modulename": "src.slune.base", "qualname": "BaseLogger.log", "kind": "function", "doc": "<p>Logs the metric/s for the current hyperparameter configuration.</p>\n\n<p>Should store metrics in some way so we can later save it using a Saver.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.slune.base.BaseLogger.read_log", "modulename": "src.slune.base", "qualname": "BaseLogger.read_log", "kind": "function", "doc": "<p>Returns value of a metric from the log based on a selection criteria.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.slune.base.BaseSaver", "modulename": "src.slune.base", "qualname": "BaseSaver", "kind": "class", "doc": "<p>Base class for all savers. </p>\n\n<p>This must be subclassed to implement different Saver classes.\nPlease name your saver class Saver<SaverName>.\nOutlines a protocol for saving and reading results to/from storage.\nMethods document what they should do once implemented.</p>\n"}, {"fullname": "src.slune.base.BaseSaver.__init__", "modulename": "src.slune.base", "qualname": "BaseSaver.__init__", "kind": "function", "doc": "<p>Initialises the saver.</p>\n\n<p>Assigns the logger instance to self.logger and makes its methods accessible through self.log and self.read_log.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- logger_instance (BaseLogger):</strong>  Instance of a logger class that inherits from BaseLogger.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">logger_instance</span><span class=\"p\">:</span> <span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">slune</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">BaseLogger</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "src.slune.base.BaseSaver.logger", "modulename": "src.slune.base", "qualname": "BaseSaver.logger", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.slune.base.BaseSaver.log", "modulename": "src.slune.base", "qualname": "BaseSaver.log", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.slune.base.BaseSaver.read_log", "modulename": "src.slune.base", "qualname": "BaseSaver.read_log", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.slune.base.BaseSaver.save_collated", "modulename": "src.slune.base", "qualname": "BaseSaver.save_collated", "kind": "function", "doc": "<p>Saves the current results in logger to storage.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.slune.base.BaseSaver.read", "modulename": "src.slune.base", "qualname": "BaseSaver.read", "kind": "function", "doc": "<p>Reads results from storage.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.slune.base.BaseSaver.exists", "modulename": "src.slune.base", "qualname": "BaseSaver.exists", "kind": "function", "doc": "<p>Checks if results already exist in storage.</p>\n\n<p>Should return integer indicating the number of runs that exist in storage for the given parameters.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.slune.loggers", "modulename": "src.slune.loggers", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.slune.loggers.default", "modulename": "src.slune.loggers.default", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.slune.loggers.default.LoggerDefault", "modulename": "src.slune.loggers.default", "qualname": "LoggerDefault", "kind": "class", "doc": "<p>Logs metric/s in a data frame.</p>\n\n<p>Stores the metric/s in a data frame that we can later save in storage.\nLogs by creating data frame out of the metrics and then appending it to the current results data frame.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>- results (pd.DataFrame):</strong>  Data frame containing all the metrics logged so far.\nEach row stores all the metrics that were given in a call to the 'log' method,\neach column title is a metric name.\nThe first column is always the time stamp at which 'log' is called.</li>\n</ul>\n", "bases": "slune.base.BaseLogger"}, {"fullname": "src.slune.loggers.default.LoggerDefault.__init__", "modulename": "src.slune.loggers.default", "qualname": "LoggerDefault.__init__", "kind": "function", "doc": "<p>Initialises the logger.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "src.slune.loggers.default.LoggerDefault.results", "modulename": "src.slune.loggers.default", "qualname": "LoggerDefault.results", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.slune.loggers.default.LoggerDefault.log", "modulename": "src.slune.loggers.default", "qualname": "LoggerDefault.log", "kind": "function", "doc": "<p>Logs the metric/s given.</p>\n\n<p>Stores them in a data frame that we can later save in storage.\nAll metrics provided will be saved as a row in the results data frame,\nthe first column is always the time stamp at which log is called.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- metrics (dict):</strong>  Metrics to be logged, keys are metric names and values are metric values.\nEach metric should only have one value! So please log as soon as you get a metric.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">metrics</span><span class=\"p\">:</span> <span class=\"nb\">dict</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.slune.loggers.default.LoggerDefault.read_log", "modulename": "src.slune.loggers.default", "qualname": "LoggerDefault.read_log", "kind": "function", "doc": "<p>Reads log and returns value according to select_by.</p>\n\n<p>Reads the values for given metric for given log and chooses metric value to return based on select_by.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- data_frame (pd.DataFrame):</strong>  Data frame containing the metric to be read.</li>\n<li><strong>- metric_name (str):</strong>  Name of the metric to be read.</li>\n<li><strong>- select_by (str, optional):</strong>  How to select the 'best' metric, currently can select by 'min' or 'max'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <ul>\n  <li>value (float): Minimum or maximum value of the metric.</li>\n  </ul>\n</blockquote>\n\n<p>TODO: \n    - Add more options for select_by.\n    - Should be able to return other types than float?</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">data_frame</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">metric_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">select_by</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;max&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.slune.savers", "modulename": "src.slune.savers", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.slune.savers.csv", "modulename": "src.slune.savers.csv", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.slune.savers.csv.SaverCsv", "modulename": "src.slune.savers.csv", "qualname": "SaverCsv", "kind": "class", "doc": "<p>Saves the results of each run in a CSV file in hierarchy of directories.</p>\n\n<p>Each directory is named after a parameter - value pair in the form \"--parameter_name=value\".\nThe paths to csv files then define the configuration under which the results were obtained,\nfor example if we only have one parameter \"learning_rate\" with value 0.01 used to obtain the results,\nto save those results we would create a directory named \"--learning_rate=0.01\" and save the results in a csv file in that directory.</p>\n\n<p>If we have multiple parameters, for example \"learning_rate\" with value 0.01 and \"batch_size\" with value 32,\nwe would create a directory named \"--learning_rate=0.01\" with a subdirectory named \"--batch_size=32\",\nand save the results in a csv file in that subdirectory.</p>\n\n<p>We use this structure to then read the results from the csv files by searching for the directory that matches the parameters we want,\nand then reading the csv file in that directory.</p>\n\n<p>The order in which we create the directories is determined by the order in which the parameters are given,\nso if we are given [\"--learning_rate=0.01\", \"--batch_size=32\"] we would create the directories in the following order:\n\"--learning_rate=0.01/--batch_size=32\".</p>\n\n<p>The directory structure generated will also depend on existing directories in the root directory,\nif there are existing directories in the root directory that match some subset of the parameters given,\nwe will create the directory tree from the deepest matching directory.</p>\n\n<p>For example if we only have the following path in the root directory:\n\"--learning_rate=0.01/--batch_size=32\"\nand we are given the parameters [\"--learning_rate=0.01\", \"--batch_size=32\", \"--num_epochs=10\"],\nwe will create the path:\n\"--learning_rate=0.01/--batch_size=32/--num_epochs=10\".\non the other hand if we are given the parameters [\"--learning_rate=0.02\", \"--num_epochs=10\", \"--batch_size=32\"],\nwe will create the path:\n\"--learning_rate=0.02/--batch_size=32/--num_epochs=10\".</p>\n\n<p>Handles parallel runs trying to create the same directories by waiting a random time (under 1 second) before creating the directory.\nShould work pretty well in practice, however, may occasionally fail depending on the number of jobs launched at the same time. </p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>- root_dir (str):</strong>  Path to the root directory where we will store the csv files.</li>\n<li><strong>- current_path (str):</strong>  Path to the csv file where we will store the results for the current run.</li>\n</ul>\n", "bases": "slune.base.BaseSaver"}, {"fullname": "src.slune.savers.csv.SaverCsv.__init__", "modulename": "src.slune.savers.csv", "qualname": "SaverCsv.__init__", "kind": "function", "doc": "<p>Initialises the csv saver. </p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- logger_instance (BaseLogger):</strong>  Instance of a logger class that inherits from BaseLogger.</li>\n<li><strong>- params (list, optional):</strong>  List of strings containing the parameters used, in form [\"--parameter_name=parameter_value\", ...], default is None.\nIf None, we will create a path using the parameters given in the log.</li>\n<li><strong>- root_dir (str, optional):</strong>  Path to the root directory where we will store the csv files, default is './tuning_results'.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">logger_instance</span><span class=\"p\">:</span> <span class=\"n\">slune</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">BaseLogger</span>,</span><span class=\"param\">\t<span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">root_dir</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;./tuning_results&#39;</span></span>)</span>"}, {"fullname": "src.slune.savers.csv.SaverCsv.root_dir", "modulename": "src.slune.savers.csv", "qualname": "SaverCsv.root_dir", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.slune.savers.csv.SaverCsv.strip_params", "modulename": "src.slune.savers.csv", "qualname": "SaverCsv.strip_params", "kind": "function", "doc": "<p>Strips the parameter values.</p>\n\n<p>Strips the parameter values from the list of parameters given,\nie. [\"--parameter_name=parameter_value\", ...] -> [\"--parameter_name=\", ...]</p>\n\n<p>Also gets rid of blank spaces.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- params (list of str):</strong>  List of strings containing the parameters used, in form [\"--parameter_name=parameter_value\", ...].</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <ul>\n  <li>stripped_params (list of str): List of strings containing the parameters used, in form [\"--parameter_name=\", ...].</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.slune.savers.csv.SaverCsv.get_match", "modulename": "src.slune.savers.csv", "qualname": "SaverCsv.get_match", "kind": "function", "doc": "<p>Searches the root directory for a path that matches the parameters given.</p>\n\n<p>If only partial matches are found, returns the deepest matching directory with the missing parameters appended.\nBy deepest we mean the directory with the most parameters matching.\nIf no matches are found creates a path using the parameters.\nCreates path using parameters in the order they are given, \nie. [\"--learning_rate=0.01\", \"--batch_size=32\"] -> \"--learning_rate=0.01/--batch_size=32\".</p>\n\n<p>If we find a partial match, we add the missing parameters to the end of the path,\nie. if we have the path \"--learning_rate=0.01\" in the root \nand are given the parameters [\"--learning_rate=0.01\", \"--batch_size=32\"],\nwe will create the path \"--learning_rate=0.01/--batch_size=32\".</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- params (list of str):</strong>  List of strings containing the arguments used, in form [\"--argument_name=argument_value\", ...].</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <ul>\n  <li>match (str): Path to the directory that matches the parameters given.</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.slune.savers.csv.SaverCsv.get_path", "modulename": "src.slune.savers.csv", "qualname": "SaverCsv.get_path", "kind": "function", "doc": "<p>Creates a path using the parameters.</p>\n\n<p>Does this by first checking for existing paths in the root directory that match the parameters given.</p>\n\n<p>Check get_match for how we create the path, \nonce we have the path we check if there is already a csv file with results in that path,\nif there is we increment the number of the results file name that we will use.</p>\n\n<p>For example if we get back the path \"--learning_rate=0.01/--batch_size=32\",\nand there exists a csv file named \"results_0.csv\" in the final directory,\nwe will name our csv file \"results_1.csv\".</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- params (list of str):</strong>  List of strings containing the arguments used, in form [\"--argument_name=argument_value\", ...].</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <ul>\n  <li>csv_file_path (str): Path to the csv file where we will store the results for the current run.</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.slune.savers.csv.SaverCsv.save_collated_from_results", "modulename": "src.slune.savers.csv", "qualname": "SaverCsv.save_collated_from_results", "kind": "function", "doc": "<p>Saves results to csv file.</p>\n\n<p>If the csv file already exists, \nwe append the collated results from the logger to the end of the csv file.\nIf the csv file does not exist,\nwe create it and save the results to it.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- results (pd.DataFrame):</strong>  Data frame containing the results to be saved.</li>\n</ul>\n\n<p>TODO: \n    - Could be making to many assumptions about the format in which we get the results from the logger,\n    should be able to work with any logger.\n    We should only be assuming that we are saving results to a csv file.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">results</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.slune.savers.csv.SaverCsv.save_collated", "modulename": "src.slune.savers.csv", "qualname": "SaverCsv.save_collated", "kind": "function", "doc": "<p>Saves results to csv file.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.slune.savers.csv.SaverCsv.read", "modulename": "src.slune.savers.csv", "qualname": "SaverCsv.read", "kind": "function", "doc": "<p>Finds the min/max value of a metric from all csv files in the root directory that match the parameters given.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- params (list of str):</strong>  Contains the parameters used, in form [\"--parameter_name=parameter_value\", ...].</li>\n<li><strong>- metric_name (string):</strong>  Name of the metric to be read.</li>\n<li><strong>- select_by (string, optional):</strong>  How to select the 'best' value for the metric from a log file, currently can select by 'min' or 'max'.</li>\n<li><strong>- avg (bool, optional):</strong>  Whether to average the metric over all runs, default is True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <ul>\n  <li>best_params (list of str): Contains the arguments used to get the 'best' value of the metric (determined by select_by).</li>\n  <li>best_value (float): Best value of the metric (determined by select_by).</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">metric_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">select_by</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;max&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">avg</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> (typing.List[str], &lt;class &#x27;float&#x27;&gt;):</span></span>", "funcdef": "def"}, {"fullname": "src.slune.savers.csv.SaverCsv.exists", "modulename": "src.slune.savers.csv", "qualname": "SaverCsv.exists", "kind": "function", "doc": "<p>Checks if results already exist in storage.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- params (list of str):</strong>  Contains the parameters used, in form [\"--parameter_name=parameter_value\", ...].</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <ul>\n  <li>num_runs (int): Number of runs that exist in storage for the given parameters.</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.slune.savers.csv.SaverCsv.get_current_path", "modulename": "src.slune.savers.csv", "qualname": "SaverCsv.get_current_path", "kind": "function", "doc": "<p>Getter function for the current_path attribute. </p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <ul>\n  <li>current_path (str): Path to the csv file where we will store the results for the current run.</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.slune.searchers", "modulename": "src.slune.searchers", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.slune.searchers.grid", "modulename": "src.slune.searchers.grid", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.slune.searchers.grid.SearcherGrid", "modulename": "src.slune.searchers.grid", "qualname": "SearcherGrid", "kind": "class", "doc": "<p>Searcher for grid search.</p>\n\n<p>Given dictionary of parameters and values to try, creates grid of all possible configurations,\nand returns them one by one for each call to next_tune.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>- configs (dict):</strong>  Parameters and values to create grid from.\nStructure of dictionary should be: { \"--parameter_name\" : [Value_1, Value_2, ...], ... }</li>\n<li><strong>- runs (int):</strong>  Controls search based on number of runs we want for each config.\nif runs &gt; 0 -> run each config 'runs' times.\nif runs = 0 -> run each config once even if it already exists.\nThis behavior is modified if we want to (use) check_existing_runs, see methods description.</li>\n<li><strong>- grid (list of dict):</strong>  List of dictionaries, each containing one combination of argument values.</li>\n<li><strong>- grid_index (int):</strong>  Index of the current configuration in the grid.</li>\n<li><strong>- saver_exists (function):</strong>  Pointer to the savers exists method, used to check if there are existing runs.</li>\n</ul>\n", "bases": "slune.base.BaseSearcher"}, {"fullname": "src.slune.searchers.grid.SearcherGrid.__init__", "modulename": "src.slune.searchers.grid", "qualname": "SearcherGrid.__init__", "kind": "function", "doc": "<p>Initialises the searcher.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- configs (dict):</strong>  Dictionary of parameters and values to try.\nStructure of dictionary should be: { \"--parameter_name\" : [Value_1, Value_2, ...], ... }</li>\n<li><strong>- runs (int, optional):</strong>  Controls search based on number of runs we want for each config.\nif runs &gt; 0 -> run each config 'runs' times.\nif runs = 0 -> run each config once even if it already exists.\nThis behavior is modified if we want to (use) check_existing_runs, see methods description.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">configs</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>, </span><span class=\"param\"><span class=\"n\">runs</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span>)</span>"}, {"fullname": "src.slune.searchers.grid.SearcherGrid.runs", "modulename": "src.slune.searchers.grid", "qualname": "SearcherGrid.runs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.slune.searchers.grid.SearcherGrid.configs", "modulename": "src.slune.searchers.grid", "qualname": "SearcherGrid.configs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.slune.searchers.grid.SearcherGrid.grid", "modulename": "src.slune.searchers.grid", "qualname": "SearcherGrid.grid", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.slune.searchers.grid.SearcherGrid.grid_index", "modulename": "src.slune.searchers.grid", "qualname": "SearcherGrid.grid_index", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.slune.searchers.grid.SearcherGrid.saver_exists", "modulename": "src.slune.searchers.grid", "qualname": "SearcherGrid.saver_exists", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.slune.searchers.grid.SearcherGrid.get_grid", "modulename": "src.slune.searchers.grid", "qualname": "SearcherGrid.get_grid", "kind": "function", "doc": "<p>Creates search grid.</p>\n\n<p>Generates all possible combinations of values for each argument in the given dictionary using recursion.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- param_dict (dict):</strong>  A dictionary where keys are argument names and values are lists of values.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <ul>\n  <li>all_combinations (list): A list of dictionaries, each containing one combination of argument values.</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">param_dict</span><span class=\"p\">:</span> <span class=\"nb\">dict</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.slune.searchers.grid.SearcherGrid.check_existing_runs", "modulename": "src.slune.searchers.grid", "qualname": "SearcherGrid.check_existing_runs", "kind": "function", "doc": "<p>We save a pointer to the savers exists method to check if there are existing runs.</p>\n\n<h6 id=\"if-there-are-n-existing-runs\">If there are n existing runs:</h6>\n\n<blockquote>\n  <p>n &lt; runs -> run the remaining runs\n  n &gt;= runs -> skip all runs</p>\n</blockquote>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- saver (BaseSaver):</strong>  Pointer to the savers exists method, used to check if there are existing runs.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">saver</span><span class=\"p\">:</span> <span class=\"n\">slune</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">BaseSaver</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.slune.searchers.grid.SearcherGrid.skip_existing_runs", "modulename": "src.slune.searchers.grid", "qualname": "SearcherGrid.skip_existing_runs", "kind": "function", "doc": "<p>Skips runs if they are in storage already.</p>\n\n<p>Will check if there are existing runs for the current configuration,\nif there are existing runs we tally them up \nand skip configs or runs of a config based on the number of runs we want for each config.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- grid_index (int):</strong>  Index of the current configuration in the grid.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <ul>\n  <li>grid_index (int): Index of the next configuration in the grid.</li>\n  <li>run_index (int): Index of the next run for the current configuration.</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">grid_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.slune.searchers.grid.SearcherGrid.next_tune", "modulename": "src.slune.searchers.grid", "qualname": "SearcherGrid.next_tune", "kind": "function", "doc": "<p>Returns the next configuration to try.</p>\n\n<p>Will skip existing runs if check_existing_runs has been called.\nFor more information on how this works check the methods descriptions for check_existing_runs and skip_existing_runs.\nWill raise an error if we have reached the end of the grid.\nTo iterate through all configurations, use a for loop like so: \n    for config in searcher: ...</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <ul>\n  <li>next_config (dict): The next configuration to try.</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.slune.slune", "modulename": "src.slune.slune", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.slune.slune.submit_job", "modulename": "src.slune.slune", "qualname": "submit_job", "kind": "function", "doc": "<p>Submits a job using specified Bash script</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- sh_path (string):</strong>  Path to the Bash script to be run.</li>\n<li><strong>- args (list of str):</strong>  List of strings containing the arguments to be passed to the Bash script.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sh_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">args</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.slune.slune.sbatchit", "modulename": "src.slune.slune", "qualname": "sbatchit", "kind": "function", "doc": "<p>Submits jobs based on arguments given by searcher.</p>\n\n<p>For each job runs the script stored at script_path with selected parameter values given by searcher\nand the arguments given by cargs.</p>\n\n<p>Uses the sbatch script with path sbatch_path to submit each job to the cluster. </p>\n\n<p>If given a Saver object, uses it to check if there are existing runs for each job and skips them,\nbased on the number of runs we would like for each job (which is stored in the saver).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- script_path (str):</strong>  Path to the script (of the model) to be run for each job.</li>\n<li><strong>- sbatch_path (str):</strong>  Path to the sbatch script that will be used to submit each job.\nExamples of sbatch scripts can be found in the templates folder.</li>\n<li><strong>- searcher (Searcher):</strong>  Searcher object used to retrieve changing arguments for each job.</li>\n<li><strong>- cargs (list, optional):</strong>  Contains arguments to be passed to the script for every job.</li>\n<li><strong>- saver (Saver, optional):</strong>  Saver object used if we want to check if there are existing runs so we don't rerun.\nCan simply not give a Saver object if you want to rerun all jobs.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">script_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">sbatch_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">searcher</span><span class=\"p\">:</span> <span class=\"n\">slune</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">BaseSearcher</span>,</span><span class=\"param\">\t<span class=\"n\">cargs</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">saver</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">slune</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">BaseSaver</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.slune.slune.lsargs", "modulename": "src.slune.slune", "qualname": "lsargs", "kind": "function", "doc": "<p>Returns the script name and a list of the arguments passed to the script.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> (&lt;class &#x27;str&#x27;&gt;, typing.List[str]):</span></span>", "funcdef": "def"}, {"fullname": "src.slune.slune.garg", "modulename": "src.slune.slune", "qualname": "garg", "kind": "function", "doc": "<p>Finds the argument/s with name arg_names in the list of arguments args_ls and returns its value/s.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- args (list of str):</strong>  List of strings containing the arguments to be searched.</li>\n<li><strong>- arg_names (str or list of str):</strong>  String or list of strings containing the names of the arguments to be searched for.       </li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <ul>\n  <li>arg_value (str or list of str): String or list of strings containing the values of the arguments found.</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">args</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">arg_names</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.slune.slune.get_csv_slog", "modulename": "src.slune.slune", "qualname": "get_csv_slog", "kind": "function", "doc": "<p>Returns a SaverCsv object with the given parameters and root directory.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- params (dict, optional):</strong>  Dictionary of parameters to be passed to the SaverCsv object, default is None.</li>\n<li><strong>- root_dir (str, optional):</strong>  Path to the root directory to be used by the SaverCsv object, default is 'slune_results'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <ul>\n  <li>SaverCsv (Saver): Saver object with the given parameters and root directory.\n  Initialized with a LoggerDefault object as its logger.</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">root_dir</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;slune_results&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">slune</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">BaseSaver</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.slune.utils", "modulename": "src.slune.utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.slune.utils.find_directory_path", "modulename": "src.slune.utils", "qualname": "find_directory_path", "kind": "function", "doc": "<p>Searches the root directory for a path of directories that matches the strings given in any order.\nIf only a partial match is found, returns the deepest matching path.\nIf no matches are found returns root_directory.\nReturns a stripped matching path of directories, ie. where we convert '--string=value' to '--string='.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- strings (list of str):</strong>  List of strings to be matched in any order. Each string in list must be in the form '--string='.</li>\n<li><strong>- root_directory (string, optional):</strong>  Path to the root directory to be searched, default is current working directory.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <ul>\n  <li>max_depth (int): Depth of the deepest matching path.</li>\n  <li>max_path (string): Path of the deepest matching path.</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">strings</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">root_directory</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;.&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.slune.utils.get_numeric_equiv", "modulename": "src.slune.utils", "qualname": "get_numeric_equiv", "kind": "function", "doc": "<p>Replaces directories in path with existing directories with the same numerical value.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- og_path (str):</strong>  Path we want to check against existing paths, must be a subdirectory of root_directory and each directory must have form '--string=value'.</li>\n<li><strong>- root_directory (str, optional):</strong>  Path to the root directory to be searched, default is current working directory.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <ul>\n  <li>equiv (str): Path with values changed to match existing directories if values are numerically equivalent, with root directory at beginning.</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">og_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">root_directory</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;.&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.slune.utils.dict_to_strings", "modulename": "src.slune.utils", "qualname": "dict_to_strings", "kind": "function", "doc": "<p>Converts a dictionary into a list of strings in the form of '--key=value'.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- d (dict):</strong>  Dictionary to be converted.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <ul>\n  <li>out (list of str): List of strings in the form of '--key=value'.</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span><span class=\"p\">:</span> <span class=\"nb\">dict</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.slune.utils.find_csv_files", "modulename": "src.slune.utils", "qualname": "find_csv_files", "kind": "function", "doc": "<p>Recursively finds all csv files in all subdirectories of the root directory and returns their paths.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- root_directory (str, optional):</strong>  Path to the root directory to be searched, default is current working directory.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <ul>\n  <li>csv_files (list of str): List of strings containing the paths to all csv files found.</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">root_directory</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;.&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.slune.utils.get_all_paths", "modulename": "src.slune.utils", "qualname": "get_all_paths", "kind": "function", "doc": "<p>Find all possible paths of csv files that have directory matching one of each of all the parameters given.</p>\n\n<p>Finds all paths of csv files in all subdirectories of the root directory that have a directory in their path matching one of each of all the parameters given.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>- dirs (list of str):</strong>  List of directory names we want returned paths to have in their path.</li>\n<li><strong>- root_directory (str, optional):</strong>  Path to the root directory to be searched, default is current working directory.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <ul>\n  <li>matches (list of str): List of strings containing the paths to all csv files found.</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dirs</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">root_directory</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;.&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();